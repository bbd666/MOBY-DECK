  

<HTML>
<HEAD>
<TITLE>Windows Standard Serial Comm Library Reference Manual</TITLE>
<STYLE TYPE="text/css">
<!-- 
  H1, H2, H3, H4, H5, H6
	{ color: ;	}
  -->
</STYLE>
</HEAD><CENTER>
<A HREF="http://www.marshallsoft.com" TARGET="_top">
<IMG SRC="http://www.marshallsoft.com/bannerM2.jpg" BORDER=0 WIDTH="600" HEIGHT="91" ALT="MarshallSoft"></A>
</A></CENTER>
<BODY BGCOLOR="white">
<BASEFONT SIZE=3>

<B><CENTER><FONT SIZE="5"> <P>Windows Standard</P>

<P>Serial Communications</P>

<P>Reference Library</P></FONT>

<P><BR>
(WSC_REF)</P>

<P><BR>
Version 4.4</P>

<P>January 19, 2009</P>

<P><BR>
This software is provided as-is.<BR>
There are no warranties, expressed or implied.</P>

<P><BR></P>

<DL compact>
  <DT>Copyright (C) 1996 </DT><DD>2009<BR>
  All rights reserved
  <BR><BR>
  <BR>
  <BR>
  </DD></DL>

<P>MarshallSoft Computing, Inc.<BR>
Post Office Box 4543<BR>
Huntsville AL 35815 USA</P>

<BR>
<BLOCKQUOTE>
  <P>Voice :   1.256.881.4630</P>

  <P>Email : info@marshallsoft.com</P>

  <P>Web : <A HREF="http://www.marshallsoft.com" TARGET="_top">www.marshallsoft.com</A></P>

  <BR>
</BLOCKQUOTE>

<P>MARSHALLSOFT is a registered trademark of MarshallSoft Computing.</P>

<P></CENTER></B><HR><I>TABLE OF CONTENTS</I></P>

<BLOCKQUOTE>
<FONT SIZE=3 STYLE="font-size:12pt;"><STRONG>1 <A HREF="#Section_1">Introduction</A></STRONG></FONT><BR>
  <BLOCKQUOTE>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>1.1 <A HREF="#Section_1.1">General Remarks</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>1.2 <A HREF="#Section_1.2">Documentation Set</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>1.3 <A HREF="#Section_1.3">Declaration Files</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>1.4 <A HREF="#Section_1.4">Language Notes</A></STRONG></FONT><BR>
  </BLOCKQUOTE>
<FONT SIZE=3 STYLE="font-size:12pt;"><STRONG>2 <A HREF="#Section_2">WSC Functions</A></STRONG></FONT><BR>
  <BLOCKQUOTE>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.1 <A HREF="#Section_2.1">SioBaud</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.2 <A HREF="#Section_2.2">SioBrkSig</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.3 <A HREF="#Section_2.3">SioByteToShort</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.4 <A HREF="#Section_2.4">SioCTS</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.5 <A HREF="#Section_2.5">SioDCD</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.6 <A HREF="#Section_2.6">SioDebug</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.7 <A HREF="#Section_2.7">SioDone</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.8 <A HREF="#Section_2.8">SioDSR</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.9 <A HREF="#Section_2.9">SioDTR</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.10 <A HREF="#Section_2.10">SioEvent</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.11 <A HREF="#Section_2.11">SioEventChar</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.12 <A HREF="#Section_2.12">SioEventWait</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.13 <A HREF="#Section_2.13">SioFlow</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.14 <A HREF="#Section_2.14">SioGetc</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.15 <A HREF="#Section_2.15">SioGetReg</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.16 <A HREF="#Section_2.16">SioGets</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.17 <A HREF="#Section_2.17">SioInfo</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.18 <A HREF="#Section_2.18">SioKeyCode</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.19 <A HREF="#Section_2.19">SioMessage</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.20 <A HREF="#Section_2.20">SioParms</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.21 <A HREF="#Section_2.21">SioPutc</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.22 <A HREF="#Section_2.22">SioPuts</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.23 <A HREF="#Section_2.23">SioRead</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.24 <A HREF="#Section_2.24">SioReset</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.25 <A HREF="#Section_2.25">SioRI</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.26 <A HREF="#Section_2.26">SioRTS</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.27 <A HREF="#Section_2.27">SioRxClear</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.28 <A HREF="#Section_2.28">SioRxQue</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.29 <A HREF="#Section_2.29">SioSetInteger</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.30 <A HREF="#Section_2.30">SioSetTimeouts</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.30 <A HREF="#Section_2.30">SioShortToByte</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.31 <A HREF="#Section_2.31">SioStatus</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.32 <A HREF="#Section_2.32">SioTimer</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.33 <A HREF="#Section_2.33">SioTxClear</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.34 <A HREF="#Section_2.34">SioTxQue</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.35 <A HREF="#Section_2.35">SioUnGetc</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>2.36 <A HREF="#Section_2.36">SioWinError</A></STRONG></FONT><BR>
  </BLOCKQUOTE>
<FONT SIZE=3 STYLE="font-size:12pt;"><STRONG>3 <A HREF="#Section_3">Modem I/O Functions</A></STRONG></FONT><BR>
  <BLOCKQUOTE>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>3.1 <A HREF="#Section_3.1">mioBreak</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>3.2 <A HREF="#Section_3.2">mioDriver</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>3.3 <A HREF="#Section_3.3">mioQuiet</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>3.4 <A HREF="#Section_3.4">mioResult</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>3.5 <A HREF="#Section_3.5">mioSendTo</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>3.6 <A HREF="#Section_3.6">mioWaitFor</A></STRONG></FONT><BR>
  </BLOCKQUOTE>
<FONT SIZE=3 STYLE="font-size:12pt;"><STRONG>4 <A HREF="#Section_4">XYM Functions</A></STRONG></FONT><BR>
  <BLOCKQUOTE>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>4.1 <A HREF="#Section_4.1">xyAbort</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>4.2 <A HREF="#Section_4.2">xyAcquire</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>4.3 <A HREF="#Section_4.3">xyDebug</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>4.4 <A HREF="#Section_4.4">xyDriver</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>4.5 <A HREF="#Section_4.5">xyGetFileName</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>4.6 <A HREF="#Section_4.6">xyGetMessage 3</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>4.7 <A HREF="#Section_4.7">xyGetParameter 4</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>4.8 <A HREF="#Section_4.8">xyRelease 5</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>4.9 <A HREF="#Section_4.9">xySetParameter 6</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>4.10 <A HREF="#Section_4.10">xySetString 7</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>4.11 <A HREF="#Section_4.11">xyStartRx 8</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>4.12 <A HREF="#Section_4.12">xyStartTx 9</A></STRONG></FONT><BR>
  </BLOCKQUOTE>
<FONT SIZE=3 STYLE="font-size:12pt;"><STRONG>5 <A HREF="#Section_5">Error Codes 0</A></STRONG></FONT><BR>
  <BLOCKQUOTE>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>5.1 <A HREF="#Section_5.1">WSC Error Codes 0</A></STRONG></FONT><BR>
<FONT SIZE=2 STYLE="font-size:10pt;"><STRONG>5.2 <A HREF="#Section_5.2">XYM Error Codes 0</A></STRONG></FONT><BR>
  </BLOCKQUOTE>
</BLOCKQUOTE>
<A NAME="Section_1"> </A>
<HR> <H2>1  Introduction</H2>

<P>The Windows Standard Serial Communications Library (WSC) is a serial communication 
component DLL library that provides full control over a serial port.  WSC uses the 
standard Windows API (Application Programmer's Interface) to communicate with any device 
connected to a serial port.</P>

<P>A simple interface allows accessing data from a serial port using RS232 or multi-drop 
RS422 / RS485 serial ports.  Windows Standard Serial Communications Library (WSC) also 
supports virtual ports such as those created by Bluetooth and USB/serial converters.</P>

<P>The WSC Reference Manual (WSC_REF) applies to the Windows Standard Serial 
Communications Library (WSC) for all supported languages.  It contains details on each 
individual WSC function.</P>

<A NAME="Section_1.1"> </A>
<HR> <H2>1.1  General Remarks</H2>

<P>All functions return an integer code.  Negative values are always errors.  See "WSC Error Codes" in Section <A HREF="#Section_5.1">5.1</A>.  Non-negative (&gt;=0) return codes are never errors.</P>


<P>Each function argument is marked as:</P>

<UL>
  <LI>(I) : 2-byte integer (Win16), 4-byte integer (Win32).</LI>

  <LI>(S) : 2-byte short integer (Win16 and Win32).</LI>

  <LI>(L) : 4-byte integer (Win16 and Win32).</LI>

  <LI>(P) : 4-byte pointer (Win16 and Win32).</LI>

</UL>

<P>Refer to the declaration files (see Section <A HREF="#Section_1.3">1.3</A> below) for the exact syntax of each WSC function.  Also note that the example programs, found in the /APPS directory, show exactly how WSC functions are called.</P>


<P>The latest version of our serial comm software and complete technical documentation can 
be found online at http://www.marshallsoft.com/serial-communication-library.htm</P>

<A NAME="Section_1.2"> </A>
<HR> <H2>1.2  Documentation Set</H2>

<P>The complete set of documentation consists of four manuals in two formats.  This is the 
third manual (WSC_REF) in the set.</P>

<UL>
  <LI>WSC_4x Programmer's Manual (WSC_4x.PDF and WSC_4x.HTM)</LI>

  <LI>WSC User's Manual (WSC_USR.PDF and WSC_USR.HTM)</LI>

  <LI>WSC Reference Manual (WSC_REF.PDF and WSC_REF.HTM)</LI>

  <LI>SERIAL User's Manual   (SERIAL.PDF and SERIAL.HTM)</LI>

</UL>

<P>Each manual comes in two formats:</P>

<UL>
  <LI>Adobe PDF (files ending in .PDF). The best format for printing manuals.</LI>

  <LI>Hyper Text (files ending in .HTM). Use any web browser to read.</LI>

</UL>

<P>The WSC_4x Programmer's Manual is the language dependent manual and provides 
information needed to compile your programs as well as the examples in the specified 
environment.  The "x" in WSC_4x Programmer's Manual specifies the host language such as C 
for C/C++, VB for Visual Basic, etc.</P>

<P>The WSC User's Manual (WSC_USR) discusses language independent serial communications 
programming issues including modem control.  It also contains purchase and license 
information.  The WSC Reference Manual (WSC_REF) contains details on each individual WSC 
function.</P>

<P>The Serial Communications Manual (SERIAL) contains background information on serial 
port hardware.</P>

<A NAME="Section_1.3"> </A>
<HR> <H2>1.3  Declaration Files</H2>

<P>The exact syntax for calling WSC functions are specific to the host language (C/C++, Delphi, VB, etc.) and are defined for each language in the "WSC declaration files".  Each WSC product comes with the appropriate declaration file for the supported language.  For example,
</P>

<PRE>
WSC4C   C/C++,NET,C#             WSC.H
WSC4VB  Visual Basic             WSC16.BAS and WSC32.BAS
        VB.NET                   WSC32.VB
        VBA (EXCEL,ACCESS,etc.)  WSC16.BAS and WSC32.BAS
WSC4PB  PowerBASIC               WSC32.PBI
WSC4D   Borland Delphi           WSC16.PAS and WSC32.PAS
WSC4CB  Fujitsu COBOL            WSC32.CBI
WSC4FP  Visual FoxPro            WSC32.FOX
WSC4DB  Visual dBase             WSC16.CC and WSC32.CC
WSC4XB  Xbase++                  WSC32.CH
</PRE>

<BR>
<A NAME="Section_1.4"> </A>
<HR> <H2>1.4  Language Notes</H2>

<P>All language versions of Windows Standard Serial Communications Library (WSC) include the example program WSCVER.  Refer to this program and the declaration file as defined in Section <A HREF="#Section_1.3">1.3</A> above to see how WSC functions are called.</P>


<P>The best way to see how a function is called is to find it used in one of the example 
programs.  All WSC functions are used in one or more examples.</P>

<A NAME="Section_1.4.1"> </A>
<H3>1.4.1 C/C++/C# (and .NET)</H3>

<P>None.</P>

<A NAME="Section_1.4.2"> </A>
<H3>1.4.2 Delphi</H3>
<OL type="1" start="1">
  <LI VALUE="1">
  Functions defined in the Delphi Unit WSCW.PAS begin with "f" rather than "Sio".</LI>

  <LI VALUE="2">
  Replace "=" with ":=" in the examples.</LI>

</OL>
<A NAME="Section_1.4.3"> </A>
<H3>1.4.3 Visual Basic (and VB.NET)</H3>

<P>None.</P>

<A NAME="Section_1.4.4"> </A>
<H3>1.4.4 PowerBASIC</H3>
<OL type="1" start="1">
  <LI VALUE="1">
  Constants defined for PowerBASIC (WSC32.PBI) begin with the character '%' symbol.</LI>

  <LI VALUE="2">
  The WSC keycode is defined in KEYCODE.PBI.</LI>

</OL>
<A NAME="Section_1.4.5"> </A>
<H3>1.4.5 Visual FoxPro</H3>

<P>All strings passed to WSC functions must be prefixed with the '@' character.</P>

<A NAME="Section_1.4.6"> </A>
<H3>1.4.6 Visual dBase</H3>

<P>None.</P>

<A NAME="Section_1.4.7"> </A>
<H3>1.4.7 Xbase++</H3>
<OL type="1" start="1">
  <LI VALUE="1">
  Functions defined for Xbase++ begin with 'X'.</LI>

  <LI VALUE="2">
  All strings passed to WSC functions must be prefixed with the '@' character.</LI>

</OL>

<A NAME="Section_2"> </A> <HR> <H2>2  WSC Functions</H2>

<A NAME="Section_2.1"> </A>
<HR> <H2>2.1  SioBaud :: Sets the baud rate.</H2>

<P><H3>SYNTAX</H3></P>


<P>SioBaud(Port, Baud)</P>
<BLOCKQUOTE>
  <P>
  Port : (I) -1 or port selected.<BR>
  </P>
  <P>
  Baud : (I) Baud code or actual baud rate.<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>REMARKS</H3>
</P>
<P>
The SioBaud function sets the baud rate without resetting the port.  It is used to change the baud rate after calling SioReset.  SioBaud may be called with either the actual baud rate value or one of the baud rate codes as follows:
</P>

<PRE>
    [VALUE]  [RATE]    [NAME]
       0       110     Baud110
       1       300     Baud300
       2      1200     Baud1200
       3      2400     Baud2400
       4      4800     Baud4800
       5      9600     Baud9600
       6     19200     Baud19200
       7     38400     Baud38400
       8     57600     Baud57600
       9    115200     Baud115200
</PRE>

<P>
Note that the baud rate does NOT have to be one listed above.  When SioReset is called, the baud rate is set to 19200 until changed by calling SioBaud.  The 19200 default baud rate can be changed by calling SioBaud with Port set to -1 before calling SioReset.  Subsequent calls to SioReset will then use the new default baud rate.
</P>
<P>
<H3>EXAMPLE</H3>
</P>
<BLOCKQUOTE>
  <P>
      Code = SioBaud(COM1, 28800)<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>RETURNS</H3>
<BR>
</P>
<UL>
  <LI>
  Return = WSC_IE_BADID  (No such port)
  </LI>
  <LI>
  Return = WSC_IE_BAUDRATE  (Unsupported baud rate)
  <BR><BR>
  <BR>
  </LI>
</UL>
<A NAME="Section_2.2"> </A>
<HR> <H2>2.2  SioBrkSig :: Asserts, cancels, or detects BREAK signal.</H2>
<P>
<H3>SYNTAX</H3>
</P>
<P>
SioBrkSig(Port, Cmd)
</P>
<BLOCKQUOTE>
  <P>
  Port : (I) Port selected.<BR>
  </P>
  <P>
  Cmd  : (I) ASSERT, CANCEL, or DETECT.<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>REMARKS</H3>
</P>
<P>
The SioBrkSig function controls the BREAK bit in the line status register.  The legal commands are:
</P>

<PRE>
     [NAME]            :  [FUNCTION]
     WSC_ASSERT_BREAK  :  to assert BREAK
     WSC_CANCEL_BREAK  :  to cancel BREAK
     WSC_DETECT_BREAK  :  to detect BREAK
</PRE>

<P>WSC_ASSERT_BREAK, WSC_CANCEL_BREAK, and WSC_DETECT_BREAK are defined in the language declaration file (see Section <A HREF="#Section_1.3">1.3</A>).</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_IE_NOPEN  (Port not opened. Call SioReset first)</LI>

  <LI>Return = WSC_RANGE  (Illegal command. Expected 'A', 'C', or 'D')
  <BR><BR>
  <BR></LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioBrkSig(Port, WSC_ASSERT_BREAK)</P>

</BLOCKQUOTE>
<A NAME="Section_2.3"> </A>
<HR> <H2>2.3  SioByteToShort :: Converts 8-bit Character Buffer to 16-bit Unicode ASCII</H2>

<P><H3>SYNTAX</H3></P>


<P>SioByteToShort(Buffer)</P>

<BLOCKQUOTE>
  <P>Buffer : (P) character buffer</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The SioByteToShort function converts the (null terminated) character buffer 'Buffer' 
from 8-bit ASCII characters to 16-bit Unicode ASCII characters.</P>


<P>The buffer must be null terminated (last character is a hex 00) and the buffer must be at least twice the size (in bytes) of the character string (since 16-bit characters require twice the space as 8-bit characters).
</P>
<P>
This function is only necessary when working with 16-bit Unicode ASCII characters.
</P>
<P>
<H3>RETURNS</H3>
</P>
<P>
None.
</P>

<PRE>
<H3>EXAMPLE</H3> (C#)

   
     char[] UnsafeBuffer = new char[128];
     // get the registration string
     fixed (char* pBuffer = UnsafeBuffer)
     Code = SioGetReg(pBuffer, 50);
     if(Code&gt;0)
       {// convert (null terminated) UnsafeBuffer[] to 16-bit chars (unicode)
        fixed (char* pBuffer = UnsafeBuffer)
        SioByteToShort(pBuffer);
       }
</PRE>

<P><H3>ALSO SEE</H3></P>


<P>SioShortToByte</P>

<A NAME="Section_2.4"> </A>
<HR> <H2>2.4  SioCTS :: Reads the Clear to Send (CTS) modem status bit.</H2>

<P><H3>SYNTAX</H3></P>


<P>SioCTS(Port)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The SioCTS function is used to detect if CTS (Clear To  Send) is set (1) or clear (0).  
Some Windows Win16 COMM drivers cannot read the CTS bit correctly!</P>


<P>The CTS line is used by some error correcting modems to implement hardware flow 
control.  CTS is dropped by the modem to signal the computer not to send data and is 
raised to signal the computer to continue.</P>


<P>Refer to the SERIAL User's Manual (SERIAL.HTM) for a discussion about flow control.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_IE_NOPEN  (Port not opened. Call SioReset first)</LI>

  <LI>Return = WSC_IE_BADID  (No such port)</LI>

  <LI>Return = 0  (CTS is clear)</LI>

  <LI>Return &gt; 0  (CTS is set)</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioCTS(Port)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>See SioFlow and SioRead.</P>

<A NAME="Section_2.5"> </A>
<HR> <H2>2.5  SioDCD :: Reads the Data Carrier Detect (DCD) modem status bit</H2>

<P><H3>SYNTAX</H3></P>


<P>SioDCD(Port)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The SioDCD function is used to read the Data Carrier Detect (DCD) modem status bit.  
Also see SioStatus.</P>


<P>SioDCD is normally used after connecting to check that the carrier has not been 
dropped.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_IE_NOPEN  (Port not opened. Call SioReset first)</LI>

  <LI>Return = WSC_IE_BADID  (No such port)</LI>

  <LI>Return = 0  (DCD is clear)</LI>

  <LI>Return &gt; 0  (DCD is set)</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioDCD(Port)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>See SioRead.</P>

<A NAME="Section_2.6"> </A>
<HR> <H2>2.6  SioDebug :: Sets and/or reads debug data.</H2>

<P><H3>SYNTAX</H3></P>


<P>SioDebug(Parm)</P>

<BLOCKQUOTE>
  <P>Parm : (I) Parameter.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>Passing the character 'R' will result in the serial port driver RESETDEV ("reset 
device") command being called when SioReset is called.  The RESETDEV command is not 
required for the operation of the UART and is not always implemented by some serial 
devices such as USB-Serial adapters.</P>


<P>Passing the character 'W' will toggle the operation of SioPuts between  (1) "wait for 
completion" [default] and (2) "immediate return" modes, as described in Section-2.9 of the 
WSC User's Manual (WSC_USR.PDF) or http://www.marshallsoft.com/wsc_usr.htm#Section_2.9</P>

<P><H3>RETURNS</H3></P>

<P>See remarks above.</P>

<P><H3>EXAMPLE</H3></P>

<P>C++ Example</P>

<BLOCKQUOTE>
  <P>     Code = SioDebug('W');</P>

</BLOCKQUOTE>

<P><H3>BASIC Example</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioDebug(ASC("W"))</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>

<P>None.</P>

<BR>
<A NAME="Section_2.7"> </A>
<HR> <H2>2.7  SioDone :: Terminates further serial processing.</H2>

<P><H3>SYNTAX</H3></P>

<P>SioDone(Port)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>

<P>The SioDone function terminates further serial port processing, allowing other 
applications to use the port.  SioDone should always be the last function called before 
exiting an application.</P>


<P>If an application is running from within an integrated development environment (IDE) 
and the application terminates without SioDone being called first, the IDE itself will 
prevent the port from being re-opened.  Terminating the IDE will free the port.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_IE_NOPEN  (Port not opened. Call SioReset first)</LI>

  <LI>Return = WSC_IE_BADID  (No such port)</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioDone(Port)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>See SioReset.</P>

<A NAME="Section_2.8"> </A>
<HR> <H2>2.8  SioDSR :: Reads the Data Set Ready (DSR) modem status bit.</H2>

<P><H3>SYNTAX</H3></P>


<P>SioDSR(Port)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The SioDSR function is used to detect if DSR (Data Set Ready) is set (1) or clear (0). 
Some Windows Win16 COMM drivers cannot read the DSR bit correctly!</P>


<P>Modems normally set DSR as soon as they are powered up.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_IE_NOPEN  (Port not opened. Call SioReset first)</LI>

  <LI>Return = WSC_IE_BADID  (No such port)</LI>

  <LI>Return = 0  (DSR is clear)</LI>

  <LI>Return &gt; 0  (DSR is set)</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioDSR(Port)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>See SioRead.</P>

<A NAME="Section_2.9"> </A>
<HR> <H2>2.9  SioDTR :: Set, clear, or read Data Terminal Ready (DTR).</H2>

<P><H3>SYNTAX</H3></P>


<P>SioDTR(Port, Cmd)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

  <P>Cmd  : (I) DTR command (see below).</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The SioDTR function controls the Data Terminal Ready (DTR) bit in the modem control register.  DTR should always be set when communicating with a modem.
</P>

<PRE>
     [NAME]          :  [FUNCTION]
     WSC_SET_LINE    :  to set DTR (ON)
     WSC_CLEAR_LINE  :  to clear DTR (OFF)
     WSC_READ_LINE   :  to read DTR
</PRE>

<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_IE_NOPEN  (Port not opened. Call SioReset first)</LI>

  <LI>Return = WSC_IE_BADID  (No such port)</LI>

  <LI>Return = WSC_RANGE  (Not one of 'S', 'C', or 'R')</LI>

  <LI>Return = 0  (DTR is clear [READ_LINE Command])</LI>

  <LI>Return &gt;0  (DTR is set [READ_LINE Command])</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioDTR(Port, WSC_SET_LINE)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>SioRead.</P>

<A NAME="Section_2.10"> </A>
<HR> <H2>2.10  SioEvent :: Efficiently waits for serial event.</H2>

<P><H3>SYNTAX</H3></P>


<P>SioEvent(Port, Mask)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

  <P>Mask : (I) Event Mask (see below).</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The SioEvent function (WIN32 only) waits (blocks) until the condition specified in 'Mask' is satisfied.  SioEvent returns (unblocks) only for events that occur after it is called.  Multiple conditions can be OR'ed together.  See example below. The event masks are:
</P>

<PRE>
     [NAME]      :  [FUNCTION]
     EV_RXCHAR   :  A character was received.
     EV_BREAK    :  A break signal was received.
     EV_CTS      :  The CTS line changed states.
     EV_DSR      :  The DSR line changed states.
     EV_ERR      :  An error was detected.
     EV_RLSD     :  The DCD line has changed states.
     EV_RING     :  The RI line has been set.
     EV_TXEMPTY  :  The TX queue has become empty.
</PRE>

<P>
Call the SioEventWait function.if an event  timeout is desired.
</P>
<P>
<H3>RETURNS</H3>
</P>
<P>
SioEvent does not return until the specified event occurs.  For this reason, it is best used inside of a thread.
<BR>
</P>
<UL>
  <LI>
  Return = WSC_IE_NOPEN     (Port not opened. Call SioReset first)
  </LI>
  <LI>
  Return = WSC_IE_BADID     (No such port)
  </LI>
  <LI>
  Return = WSC_IO_ERROR     (An event error has occurred)
  </LI>
  <LI>
  Return = WSC_IO_COMPLETE  (success - event has occurred)
  </LI>
  <LI>
  Return = WSC_IO_PENDING   (fails - event has not occurred)
  </LI>
</UL>
<P>
WSC_IO_PENDING will be returned by SioEvent if timeout has occurred.
</P>
<P>
<H3>EXAMPLE</H3>
</P>
<P>
<H3>C/C++ Example</H3>
</P>

<PRE>
     // wait until CTS or DSR changes states.
     Code = SioEvent(Port, EV_CTS|EV_DSR)

<H3>BASIC Example</H3>

//   ' wait until CTS or DSR changes states.
     Code = SioEvent(Port, EV_CTS OR EV_DSR)
</PRE>

<P><H3>ALSO SEE</H3></P>


<P>SioEventChar, SioEventWait, and SioMessage.</P>

<BR>
<A NAME="Section_2.11"> </A>
<HR> <H2>2.11  SioEventChar :: Efficiently waits for a serial character.</H2>

<P><H3>SYNTAX</H3></P>


<P>SioEventChar(Port, EvtChar, Timeout)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

  <P>EvtChar : (I) Event character.</P>

  <P>Timeout : (I) Timeout (milliseconds).</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The SioEventChar function (WIN32 only) waits (blocks) until the specified character is 
seen in the serial input stream or timeout occurs. SioEventChar returns (unblocks) only 
when the specified character is received after it is called.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_IE_NOPEN     (Port not opened. Call SioReset first)</LI>

  <LI>Return = WSC_IE_BADID     (No such port)</LI>

  <LI>Return = WSC_IO_ERROR     (An event error has occurred)</LI>

  <LI>Return = WSC_IO_COMPLETE  (success - event has occurred)</LI>

  <LI>Return = WSC_IO_PENDING   (fails - event has not occurred)
  <BR><BR>
  <BR>
  </LI>
</UL>
<P>
WSC_IO_PENDING will be returned by SioEventChar if timeout has occurred.
</P>
<P>
<H3>EXAMPLE</H3>
</P>
<P>
<H3>C/C++ Example</H3>
</P>

<PRE>
     // wait (up to 1 second) until a carriage return is seen.
     Code = SioEventChar(Port, '\r', 1000)

<H3>BASIC Example</H3>

     ' wait (up to 1 second) until a carriage return [ Chr(13) ] is seen.
     Code = SioEventChar(Port, 13, 1000)
</PRE>

<P><H3>ALSO SEE</H3></P>


<P>SioEvent and SioEventWait.</P>

<A NAME="Section_2.12"> </A>
<HR> <H2>2.12  SioEventWait :: Efficiently waits for a serial event.</H2>

<P><H3>SYNTAX</H3></P>


<P>SioEventWait(Port, Mask, Timeout)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

  <P>Mask : (I) Event Mask (see below).</P>

  <P>Timeout : (I) Timeout (milliseconds).</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The SioEventWait function (WIN32 only) waits (blocks) until the condition specified in 
'Mask' is satisfied or the timeout is reached. SioEventWait returns (unblocks) only for 
events that occur after it is called unless the specified timeout period is reached.  
Multiple conditions can be OR'ed together.  See the example below. The event masks can be 
found in the description of SioEvent entry above.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_IE_NOPEN     (Port not opened. Call SioReset first)</LI>

  <LI>Return = WSC_IE_BADID     (No such port)</LI>

  <LI>Return = WSC_IO_ERROR     (An event error has occurred)
  </LI>
  <LI>
  Return = WSC_IO_COMPLETE  (success - event has occurred)
  </LI>
  <LI>
  Return = WSC_IO_PENDING   (fails - event has not occurred)
  </LI>
</UL>
<P>
WSC_IO_PENDING will be returned by SioEventWait if timeout has occurred.
</P>
<P>
<H3>EXAMPLE</H3>
</P>
<P>
<H3>C/C++ Example</H3>
</P>

<PRE>
     // Wait (up to 1.5 seconds) for incoming serial data.
     Code = SioEventWait(Port, EV_RXCHAR, 1500)

<H3>BASIC Example</H3>

     ' Wait (up to 1.5 seconds) for incoming serial data.
     Code = SioEventWait(Port, EV_RXCHAR, 1500)
</PRE>

<P>
<H3>ALSO SEE</H3>
</P>
<P>
SioEvent and SioEventChar.
</P>
<P>
<BR>
</P>
<A NAME="Section_2.13"> </A>
<HR> <H2>2.13  SioFlow :: Sets flow control protocol.</H2>
<P>
<H3>SYNTAX</H3>
</P>
<P>
SioFlow(Port, Cmd)
</P>
<BLOCKQUOTE>
  <P>
  Port : (I) Port selected.<BR>
  </P>
  <P>
  Cmd  : (I) Class of flow control (see below).<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>REMARKS</H3>
</P>
<P>
The SioFlow function is used to enable or disable hardware flow control.  Hardware flow control uses RTS and CTS to control data flow between the modem and the computer.  To enable flow control, call SioFlow with 'Cmd' set to:
</P>

<PRE>
     [NAME]                     :  [FUNCTION]
     WSC_HARDWARE_FLOW_CONTROL  :  Hardware (RTS/CTS) flow control.
     WSC_SOFTWARE_FLOW_CONTROL  :  Software (XON/XOFF) flow control.
     WSC_NO_FLOW_CONTROL        :  No flow control [default].
</PRE>

<P>In order for flow control to work correctly, your serial device must also be configured 
to work with the same class of flow control (hardware or software).  If using hardware 
flow control, the computer to serial device cable must have RTS and CTS wired straight 
through.  If hardware flow control is enabled, the RTS line should not be modified by 
calling SioRTS.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_RANGE  (Cannot recognize command)</LI>

  <LI>Return &gt; 0  (Flow control enabled)</LI>

  <LI>Return = 0  (Flow control disabled)</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioFlow(Port, WSC_HARDWARE_FLOW_CONTROL)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>SioPutc and SioSetTimeouts.</P>

<A NAME="Section_2.14"> </A>
<HR> <H2>2.14  SioGetc :: Reads the next character from the serial line.</H2>


<P><H3>SYNTAX</H3></P>


<P>SioGetc(Port)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The SioGetc function reads the next byte from the receive queue of the selected serial 
port.  WSC_NO_DATA (-100) is returned if no byte is available.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_IE_NOPEN  (Port not opened. Call SioReset first)</LI>

  <LI>Return = WSC_IE_BADID  (No such port)</LI>

  <LI>Return = WSC_NO_DATA  (no data available)</LI>

  <LI>Return &gt;= 0  (character read)</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioGetc(Port)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>SioUnGetc and SioGets.</P>

<A NAME="Section_2.15"> </A>
<HR> <H2>2.15  SioGetReg :: Returns the license registration string.</H2>

<P><H3>SYNTAX</H3></P>


<P>SioGetReg(Buffer, BufLen)</P>

<BLOCKQUOTE>
  <P>Buffer : (P) Buffer for registration string.</P>

  <P>BufLen : (I) Length of above buffer.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>

<P>The SioGetReg function copies the license registration string (a maximum of 50 bytes) 
to 'Buffer'.</P>

<P>The registration string identified the purchaser and is embedded in each registered 
DLL.</P>

<P><H3>RETURNS</H3></P>

<P>Number of bytes copied.</P>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Length = SioGetReg (Buffer, 50)</P>

  <BR>
</BLOCKQUOTE>
<A NAME="Section_2.16"> </A>
<HR> <H2>2.16  SioGets :: Reads the next byte buffer from the serial line.</H2>

<P><H3>SYNTAX</H3></P>

<P>SioGets(Port, String, Cnt)</P>

<BLOCKQUOTE>
  <P>Port   : (I) Port selected.</P>

  <P>String : (P) Pointer to receive buffer.</P>

  <P>Cnt    : (I) Number of bytes to read.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>

<P>The SioGets function reads the smaller of the number of bytes wanted (Cnt) and the number of bytes in the receive buffer.  A zero is returned if no bytes are read.
</P>
<P>
Note that even if the data is being sent in one operation by the other side, it may not necessarily arrive all at in a single packet.
</P>
<P>
<H3>RETURNS</H3>
<BR>
</P>
<UL>
  <LI>
  Return = WSC_IE_NOPEN  (Port not opened. Call SioReset first)
  </LI>
  <LI>
  Return = WSC_IE_BADID  (No such port)
  </LI>
  <LI>
  Return &gt;= 0  (Number of characters actually read)
  </LI>
</UL>
<P>
<H3>EXAMPLE</H3>
</P>
<P>
<H3>C/C++ Example</H3>
</P>

<PRE>
     char Buffer[128];
     Code = SioGets(Port, (LPSTR)Buffer, 128)

<H3>BASIC Example</H3>

     Dim Buffer As String * 128
     Code = SioGets(Port, Buffer, 128)
</PRE>

<P>
<H3>ALSO SEE</H3>
</P>
<P>
SioUnGetc and SioPutc.
</P>
<A NAME="Section_2.17"> </A>
<HR> <H2>2.17  SioInfo :: Returns WSC library version information.</H2>
<P>
<H3>SYNTAX</H3>
</P>
<P>
SioInfo(Cmd)
</P>
<BLOCKQUOTE>
  <P>
  Cmd : (I) Command (See below)<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>REMARKS</H3>
</P>
<P>
The SioInfo function returns an integer code corresponding to the Cmd as follows.
</P>

<PRE>
     [NAME]            :  [FUNCTION]
     WSC_GET_VERSION   :  Library version number [3 hex digits].
     WSC_GET_BUILD     :  Library build number.
</PRE>

<P><BR>
SioInfo(WSC_GET_VERSION) will return the 3 digit version number embedded in WSC16.DLL and 
in WSC32.DLL.  The 3 digit version number is formatted as the rightmost 3 nibbles (4 bits 
per nibble) of the return value.  SioInfo(WSC_GET_BUILD) will return the version build 
number.</P>

<P>Refer to the WSCVER program for an example.</P>

<P><H3>RETURNS</H3></P>

<P>See remarks above.</P>

<BLOCKQUOTE>
  <P>Return = -1  (Cannot recognize command)</P>

</BLOCKQUOTE>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioInfo(WSC_GET_VERSION)</P>

</BLOCKQUOTE>
<A NAME="Section_2.18"> </A>
<HR> <H2>2.18  SioKeyCode :: Pass keycode to WSC32.DLL</H2>

<P><H3>SYNTAX</H3></P>

<P>SioKeyCode(KeyCode)</P>

<BLOCKQUOTE>
  <P>KeyCode : (L) Keycode value (0 or 8 to 10 digit number)</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The SioKeyCode function must be the first WSC call made.</P>

<P>When WSC is registered, you will receive a 'keycode'  (an 8 to 10 digit number) that 
matches the 'keycode' within the registered version of the DLL.  For the evaluation 
(shareware) version, the keycode is 0.  See file KEYCODE.</P>

<P><H3>EXAMPLE</H3></P>

<P>All example programs call SioKeyCode</P>

<BLOCKQUOTE>
  <P>    Code = SioKeyCode(WSC_KEY_CODE)</P>

</BLOCKQUOTE>

<P><H3>RETURNS</H3></P>

<BLOCKQUOTE>
  <P>Return &gt;= 0 No error.</P>

  <P>Return = WSC_KEYCODE (wrong keycode)</P>

</BLOCKQUOTE>
<A NAME="Section_2.19"> </A>
<HR> <H2>2.19  SioMessage :: Send windows message when event occurs.</H2>

<P><H3>SYNTAX</H3></P>

<P>SioMessage(Port, Handle, Message, Mask)</P>

<BLOCKQUOTE>
  <P>Port   : (I) Port selected.</P>

  <P>Handle : (S) Window handle (HWND).</P>

  <P>Message: (I) Message (Usually WM_USER).</P>

  <P>Mask   : (L) Event mask (see SioEvent).</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>

<P>The SioMessage function will post the message 'Message' to the window handle 'Handle' 
when event 'Mask' occurs.  SioMessage does not block.</P>

<P>Call SioMessage(Port, 0, 0, 0) in order to cancel a previous event.</P>

<P>Refer to SioEvent for a list of mask values.</P>

<P><H3>RETURNS</H3></P>

<P>See remarks above.</P>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioMessage(Port, hWnd, WM_USER, EV_RXCHAR)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>

<P>SioEvent, SioEventChar, and SioEventWait</P>

<A NAME="Section_2.20"> </A>
<HR> <H2>2.20  SioParms :: Sets parity, stop bits, and word length.</H2>

<P><H3>SYNTAX</H3></P>

<P>SioParms(Port, Parity, StopBits, DataBits)</P>

<BLOCKQUOTE>
  <P>Port     : (I) -1 or port selected.</P>

  <P>Parity   : (I) Parity code.</P>

  <P>StopBits : (I) Stop bits code.</P>

  <P>DataBits : (I) Word length code.</P>

</BLOCKQUOTE>
<P>
<H3>REMARKS</H3>
</P>
<P>
The SioParms function sets the parity, stop bits, and word length values.
</P>
<P>
SioParms can be called either before or after calling SioReset.  Call SioParms with Port set to -1 before calling SioReset to make the passed parameters the default.  Use the constant values defined in the WSC declaration file (see Section <A HREF="#Section_1.3">1.3</A>) to minimize the chance of passing an incorrect parameter value.
</P>
<P>
<BR>

<PRE>
     [PARITY]     [STOPBITS]     [DATABITS]
     NoParity     OneStopBit     WordLength7
     OddParity    One5StopBits   WordLength8
     EvenParity   TwoStopBits    --
     SpaceParity  --             --
     MarkParity   --             --
</PRE>

</P>


<P><BR>
<H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_IE_BADID  (No such port)</LI>

  <LI>Return = WSC_IE_BYTESIZE  (Word length not supported)</LI>

  <LI>Return = WSC_RANGE  (Parameter out of range)</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioParms(Port, WSC_NoParity, WSC_OneStopBit, WSC_WordLength8)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>SioReset.</P>

<A NAME="Section_2.21"> </A>
<HR> <H2>2.21  SioPutc :: Transmit a character over a serial line.</H2>

<P><H3>SYNTAX</H3></P>


<P>SioPutc(Port, Ch)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

  <P>Ch   : (I) Character to send.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The SioPutc function copies the character to the transmit queue for subsequent 
transmission by the UART.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_IE_NOPEN  (Port not opened. Call SioReset first)</LI>

  <LI>Return = WSC_IE_BADID  (No such port)</LI>

  <LI>Return = 1 (No error)</LI>

</UL>

<P><H3>EXAMPLE</H3></P>


<P><H3>C/C++ Example</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioPutc(Port, 'A')</P>

</BLOCKQUOTE>

<P><H3>BASIC Example</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioPutc(Port, ASC("A"))</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>SioGetc, SioFlow, and SioSetTimeouts.</P>

<A NAME="Section_2.22"> </A>
<HR> <H2>2.22  SioPuts :: Transmits a byte buffer over a serial line.</H2>

<P><H3>SYNTAX</H3></P>


<P>SioPuts(Port, String, Count)</P>

<BLOCKQUOTE>
  <P>Port   : (I) Port selected.</P>

  <P>String : (P) Pointer to string of bytes to transmit.</P>

  <P>Count  : (I) Number of bytes to transmit.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The SioPuts function copies 'Count' bytes from 'String' to the transmit queue for 
transmission. The 'String' can contain any ASCII or binary values.</P>

<DL compact>
  <DT>The SioPuts function can operate in two ways</DT><DD>"wait for completion" and "immediate return", as described in Section-2.9 of the WSC User's Manual (WSC_USR.PDF) or
  http://www.marshallsoft.com/wsc_usr.htm#Section_2.9
  </DD>
</DL>
<P>
<H3>RETURNS</H3>
<BR>
</P>
<UL>
  <LI>
  Return = WSC_IE_NOPEN  (Port not opened. Call SioReset first)
  </LI>
  <LI>
  Return = WSC_IE_BADID  (No such port)
  </LI>
  <LI>
  Return &gt;= 0  (The number of bytes accepted for transmission)
  </LI>
</UL>
<P>
<H3>EXAMPLE</H3>
</P>
<P>
<H3>C/C++ Example</H3>
</P>

<PRE>
     char Buffer[128];
     Code = SioPuts(Port, (LPSTR)Buffer, 128)

<H3>BASIC Example</H3>

     Dim Buffer As String * 128
     Code = SioPuts(Port, Buffer, 128)
</PRE>

<P>
<H3>ALSO SEE</H3>
</P>
<P>
SioGetc, SioFlow, and SioSetTimeouts.
</P>
<A NAME="Section_2.23"> </A>
<HR> <H2>2.23  SioRead :: Reads any UART register.</H2>
<P>
<H3>SYNTAX</H3>
</P>
<P>
SioRead(Port, Reg)
</P>
<BLOCKQUOTE>
  <P>
  Port : (I) Port selected.<BR>
  </P>
  <P>
  Reg  : (I) UART register (0 to 7).<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>REMARKS</H3>
</P>
<P>
SioRead is ONLY for Win16 applications running under Windows 95 and 98.  The SioRead function reads any of the 7 I/O ports directly, by-passing the Windows API.  The line status and the modem status registers can be read by (in C/C++):
</P>

<PRE>
   #define SioLine(Port) SioRead(Port,5)
   #define SioModem(Port) SioRead(Port,6)
</PRE>

Note that all modem and/or line status bits can also be read using SioDTR, SioRTS, SioDCD, SioRI, SioDSR, and SioCTS.  Refer to the SERIAL User's Manual (SERIAL.PDF or http://www.marshallsoft.com/serial.htm)  for a discussion of the UART registers.
<H3>RETURNS</H3>
<BR>
<UL>
  <LI>
  Return = WSC_IE_NOPEN  (Port not opened. Call SioReset first)
  </LI>
  <LI>
  Return = WSC_IE_BADID  (No such port)
  </LI>
  <LI>
  Return = &gt;0  (Contents of selected UART register)
  </LI>
</UL>
<P>
<H3>EXAMPLE</H3>
</P>
<BLOCKQUOTE>
  <P>
       Code = SioRead(Port, 5)<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>ALSO SEE</H3>
</P>
<P>
SioStatus.
</P>
<A NAME="Section_2.24"> </A>
<HR> <H2>2.24  SioReset :: Initialize a serial port for processing.</H2>
<P>
<H3>SYNTAX</H3>
</P>
<P>
SioReset(Port, RxQueSize, TxQueSize)
</P>

<PRE>
   Port      : (I) Port selected (or -1: see below).
   RxQueSize : (I) Receive queue size.
   TxQueSize : (I) Transmit queue size.
</PRE>

<P>
<H3>REMARKS</H3>
</P>
<P>
The SioReset function initializes (opens) the selected serial port.  SioReset should be called before making any other calls to WSC except for setting default behavior (port=-1).  SioReset uses the parity, stop bits, and word length value previously set if SioParms was called otherwise the default values (19200, no parity, 8 data, 1 stop) are used.
</P>
<P>
SioReset can be called with Port set to -1 in order to specify the behavior of DTR and RTS at port initialization:
</P>

<PRE>
     SioReset(-1, DTR_Default, RTS_Default)
</PRE>

<P>DTR will be set at port initialization if DTR_Default is 1, else DTR will be cleared.  
This is also the case for RTS_Default.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_IE_BADID  (No such port)</LI>

  <LI>Return = WSC_IE_OPEN  (Already open)</LI>

  <LI>Return = WSC_IE_MEMORY  (Cannot allocate memory)</LI>

  <LI>Return = WSC_IE_HARDWARE  (Hardware error)</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioReset(Port, 1024, 1024)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>SioBaud, SioParms, and SioDone.</P>

<A NAME="Section_2.25"> </A>
<HR> <H2>2.25  SioRI :: Reads the Ring Indicator (RI) modem status bit.</H2>

<P><H3>SYNTAX</H3></P>


<P>SioRI(Port)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The SioRI function is used to read the Ring Indicator (RI) modem status bit.  It is 
recommended that incoming rings be detected by looking for the text "RING" in the input 
stream rather than the RI signal since some modems do not set the RI reliably.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_IE_NOPEN  (Port not opened. Call SioReset first)</LI>

  <LI>Return = WSC_IE_BADID  (No such port)</LI>

  <LI>Return = 0   (RI is clear)</LI>

  <LI>Return = &gt;0  (RI is set - RING has occurred)</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioRI(Port)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>SioRead.</P>

<A NAME="Section_2.26"> </A>
<HR> <H2>2.26  SioRTS :: Sets, clears, or reads the Request to Send (RTS).</H2>

<P><H3>SYNTAX</H3></P>


<P>SioRTS(Port, Cmd)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

  <P>Cmd  : (I) RTS command (SET, CLEAR, or READ).</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The SioRTS function controls the Request to Send (RTS bit in the modem control register).
</P>
<P>
The RTS line is used by some error correcting modems to implement hardware flow control.  RTS is dropped by the computer to signal the modem not to send data and is raised to signal the modem to continue.  RTS should be set when communicating with a modem unless flow control is being used.
</P>
<P>
Refer to the SERIAL User's Manual (SERIAL.PDF or http://www.marshallsoft.com/serial.htm) for a discussion of flow control.  Commands (defined in WSC declaration file [Section <A HREF="#Section_1.3">1.3</A>]) are:
</P>

<PRE>
     [NAME]          :  [FUNCTION]
     WSC_SET_LINE    :  set RTS (ON)
     WSC_CLEAR_LINE  :  clear RTS (OFF)
     WSC_READ_LINE   :  read RTS
</PRE>

<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return =  WSC_IE_NOPEN  (Port not opened. Call SioReset first)</LI>

  <LI>Return =  WSC_IE_BADID  (No such port)</LI>

  <LI>Return =  WSC_RANGE  (Command is not one of 'S', 'C', or 'R')</LI>

  <LI>Return =  0  (RTS is clear ['R' command])</LI>

  <LI>Return &gt;  0  (RTS is set ['R' command])</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioRTS(Port, WSC_CLEAR_LINE)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>SioFlow and SioDTR.</P>

<A NAME="Section_2.27"> </A>
<HR> <H2>2.27  SioRxClear :: Clears the receive buffer.</H2>

<P><H3>SYNTAX</H3></P>


<P>SioRxClear(Port)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The SioRxClear function will delete any characters in the receive buffer (not the UART) 
for the specified port.  After execution, the receive buffer will be empty.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_IE_NOPEN  (Port not opened. Call SioReset first)</LI>

  <LI>Return = WSC_IE_BADID  (No such port)</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioRxClear(Port)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>SioRxQue.</P>

<A NAME="Section_2.28"> </A>
<HR> <H2>2.28  SioRxQue :: Returns the number of bytes in the receive queue.</H2>

<P><H3>SYNTAX</H3></P>


<P>SioRxQue(Port)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The SioRxQue function will return the number of bytes in the receive queue  (not the 
UART) at the time of the call.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_IE_NOPEN  (Port not opened. Call SioReset first)</LI>

  <LI>Return = WSC_IE_BADID  (No such port)</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioRxQue(Port)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>See SioTxQue</P>

<A NAME="Section_2.29"> </A>
<HR> <H2>2.29  SioSetInteger :: Sets integer parameter for serial processing.</H2>
<P>
<H3>SYNTAX</H3>
</P>
<P>
SioSetInteger(Port, ParamName, ParamValue)
</P>

<PRE>
Port      : (I) Port selected.
ParmName  : (I) Parameter name (integer code)
ParmValue : (L) Parameter value
</PRE>

<P>
<H3>REMARKS</H3>
</P>
<P>
The parameter values defined are as follows:
</P>

<PRE>
     [NAME]           :  [FUNCTION]
     WSC_WAIT_ON_PUTS :  Complete I/O before returning   ['W']
     WSC_SIGNAL       :  Signal thread blocking on SioEvent ['S']
     WSC_OVERLAPPED   :  Force overlapped I/O ['O']
</PRE>

<P>
WSC_WAIT_ON_PUTS is used to direct SioPuts to return immediately (before the I/O is complete) if ParamValue is TRUE (not 0). The default is 0 (FALSE), which means that SioPuts will not return until the I/O is completed.
</P>
<P>
WSC_SIGNAL is used to signal WSC to release the block created when SioEvent was called.
</P>
<BLOCKQUOTE>
  <P>
  WSC_OVERLAPPED is used to disable all overlapped I/O (pass ParmValue = 0).  By default, WSC32 will use overlapped I/O when running on Win98 (and above) machines, but not on Win95 machines, since Win95 does not support overlapped I/O.<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>RETURNS</H3>
</P>
<P>
The parameter value is returned if the parameter name is recognized, otherwise -1 is returned.
</P>
<P>
<H3>EXAMPLE</H3>
</P>

<PRE>
     SioSetInteger(Port, WSC_WAIT_ON_PUTS, 1)
   
     SioSetInteger(Port, WSC_SIGNAL, 1)
</PRE>

<P>
</P>
<A NAME="Section_2.30"> </A>
<HR> <H2>2.30  SioSetTimeouts :: Sets Transmit and Receive Timeout Constants.</H2>
<P>
<H3>SYNTAX</H3>
</P>
<P>
SioSetTimeouts(Port,ReadInter,ReadMult,ReadCons,WriteMult,WriteCons)
</P>

<PRE>
Port      : (I) port selected
ReadInter : (I) read interval t/o
ReadMult  : (I) read t/o multiplier
ReadCons  : (I) read t/o constant
WriteMult : (I) write t/o multiplier
WriteCons : (I) write t/o constant
</PRE>

<P><H3>REMARKS</H3></P>

<P>Sets the transmit (SioPutc/SioPuts) &amp; receive (SioGetc/SioGets) operation 
timeouts.</P>

<P>If the value returned by SioPutc is 0, then a timeout has occurred. If the value 
returned by SioPuts is less than the number of bytes passed as the last argument to 
SioPuts, then a timeout has occurred.</P>

<P>WSC_READ_INTERVAL_TIMEOUT (ReadInter)<BR>
Sets the maximum period of time (in milliseconds) allowed between two sequential bytes 
being read from the serial port before the receive operation terminates.</P>

<P>If set to MAXDWORD and the other two above READ timeouts are set to zero, then serial 
receive calls return immediately without waiting.</P>

<P>WSC_READ_TIMEOUT_MULTIPLIER (ReadMult)<BR>
Sets the multiplier (in milliseconds) used to calculate the overall timeout of serial 
receive operations. This timeout is given by:</P>

<BLOCKQUOTE>
  <P>NbrBytes * ReadTimeoutMultiplier + ReadTimeoutConstant   (NbrBytes = # bytes 
  requested)</P>

</BLOCKQUOTE>

<P>WSC_READ_TIMEOUT_CONSTANT (ReadConst)<BR>
Sets the constant (in milliseconds) used to calculate the overall timeout of serial 
receive operations. This timeout is given by:</P>

<BLOCKQUOTE>
  <P>NbrBytes * ReadTimeoutMultiplier + ReadTimeoutConstant   (NbrBytes = # bytes 
  requested</P>

</BLOCKQUOTE>

<P>WSC_WRITE_TIMEOUT_MULTIPLIER (WriteMult)<BR>
Sets the multiplier (in milliseconds) used to calculate the overall timeout of serial 
transmit operations. This timeout is given by:</P>

<BLOCKQUOTE>
  <P>NbrBytes * WriteTimeoutMultiplier + WriteTimeoutConstant   (NbrBytes = # bytes requested)</P>

</BLOCKQUOTE>

<P>WSC_WRITE_TIMEOUT_CONSTANT (WriteCons)<BR>
Sets the constant (in milliseconds) used to calculate the overall timeout of serial transmit operations. This timeout is given by:
</P>
<BLOCKQUOTE>
  <P>
  NbrBytes * WriteTimeoutMultiplier + WriteTimeoutConstant   (NbrBytes = # bytes requested)<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>RETURNS</H3>
<BR>
</P>
<UL>
  <LI>
  Return = WSC_WIN32ERR (cannot set timeouts)
  </LI>
</UL>
<P>
<H3>EXAMPLE</H3>
</P>

<PRE>
     SioSetTimeouts(Port,(DWORD)-1,(DWORD)0,(DWORD)0,(DWORD)1,(DWORD)2000);
</PRE>

<P>
</P>
<A NAME="Section_2.31"> </A>
<HR> <H2>2.31  SioShortToByte :: Converts 16-bit Unicode ASCII character buffer to 8-bit</H2>
<P>
<H3>SYNTAX</H3>
</P>
<P>
SioShortToByte(Buffer)
</P>
<BLOCKQUOTE>
  <P>
  Buffer : (P) character buffer<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>REMARKS</H3>
</P>
<P>
The SioShortToByte function converts the (null terminated) character buffer 'Buffer' from 16-bit Unicode ASCII characters to 8-bit ASCII characters.
</P>
<P>
The buffer must be null terminated (last character is a hex 00).
</P>
<P>
This function is only necessary when working with 16-bit Unicode ASCII characters.
</P>
<P>
<H3>RETURNS</H3>
</P>
<P>
None.
</P>

<PRE>
<H3>EXAMPLE</H3> (C#)

   
     NameString = "MyFile.zip\0"
     char[] NameBuffer = NameString.ToCharArray();
     // convert (null terminated) 16-unicode buffer to 8-bit
     fixed (char* pNameBuffer = NameBuffer)
     SioShortToByte(pNameBuffer);
   
</PRE>

<P>
<H3>ALSO SEE</H3>
</P>
<P>
SioByteToShort
</P>
<A NAME="Section_2.32"> </A>
<HR> <H2>2.32  SioStatus :: Returns the serial port status.</H2>
<P>
<H3>SYNTAX</H3>
</P>
<P>
SioStatus(Port, Mask)
</P>
<BLOCKQUOTE>
  <P>
  Port : (I) Port selected.<BR>
  </P>
  <P>
  Mask : (I) Error mask.<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>REMARKS</H3>
</P>
<P>
The SioStatus function returns the serial port error status corresponding to the mask argument.
</P>

<PRE>
     [MASK NAME]  :  [FUNCTION]
     WSC_RXOVER   :  The receive queue overflowed.
     WSC_OVERRUN  :  An incoming byte was overwritten.
     WSC_PARITY   :  A parity error was detected (incoming byte)
     WSC_FRAME    :  A framing error was detected (incoming byte)
     WSC_BREAK    :  A break signal was detected.
     WSC_TXFULL   :  The transmit queue is full.
</PRE>

<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_IE_NOPEN  (Port not opened. Call SioReset first)</LI>

  <LI>Return = WSC_IE_BADID  (No such port)</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioStatus(Port, WSC_FRAME)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>SioRead.</P>

<A NAME="Section_2.33"> </A>
<HR> <H2>2.33  SioTimer :: Returns the current time in milliseconds.</H2>

<P><H3>SYNTAX</H3></P>


<P>SioTimer()</P>


<P><H3>REMARKS</H3></P>


<P>The SioTimer returns the system time in milliseconds.  SioTimer calls the Windows API 
function GetCurrentTime.  This function is provided as a convenience since GetCurrentTime 
could be called directly from most computer languages.</P>


<P><H3>RETURNS</H3></P>


<P>The system time in milliseconds.</P>


<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     TimeNow = SioTimer()</P>

  <BR>
</BLOCKQUOTE>
<A NAME="Section_2.34"> </A>
<HR> <H2>2.34  SioTxClear :: Clears the transmit buffer.</H2>

<P><H3>SYNTAX</H3></P>


<P>SioTxClear(Port)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The SioTxClear function will delete any characters in the transmit buffer (not the 
UART) for the specified port.</P>


<P>Once this function is called, any character in the transmit buffer (put there by 
SioPutc or SioPuts) will be lost and therefore not transmitted.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_IE_NOPEN  (Port not opened. Call SioReset first)</LI>

  <LI>Return = WSC_IE_BADID  (No such port)</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioTxClear(Port)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>SioTxQue.</P>

<A NAME="Section_2.35"> </A>
<HR> <H2>2.35  SioTxQue :: Returns the number of bytes in the transmit queue.</H2>

<P><H3>SYNTAX</H3></P>


<P>SioTxQue(Port)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The SioTxQue function will return the number of characters in the transmit queue (not 
the UART) at the time of the call.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_IE_NOPEN  (Port not opened. Call SioReset first)</LI>

  <LI>Return = WSC_IE_BADID  (No such port)</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioTxQue(Port)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>SioRxQue.</P>

<A NAME="Section_2.36"> </A>
<HR> <H2>2.36  SioUnGetc :: "Ungets" the last character read with SioGetc().</H2>

<P><H3>SYNTAX</H3></P>


<P>SioUnGetc(Port, Ch)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

  <P>Ch   : (I) Character to unget.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The SioUnGetc function returns ("pushes") the character back into the serial input 
buffer.  The character pushed will be the next character returned by SioGetc.  Only one 
character can be pushed back.  This function works just like the "ungetc" function in the 
C language.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = WSC_IE_NOPEN  (Port not opened. Call SioReset first)</LI>

  <LI>Return = WSC_IE_BADID  (No such port)</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = SioUnGetc(Port)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>SioReset.</P>

<A NAME="Section_2.37"> </A>
<HR> <H2>2.37  SioWinError :: Return last Win32 error code &amp; message text.</H2>

<P><H3>SYNTAX</H3>
</P>
<P>
SioWinError(Buffer, Size)
</P>
<BLOCKQUOTE>
  <P>
  Buffer : (P) Pointer to messages buffer.<BR>
  </P>
  <P>
  Size   : (I) Size of buffer.<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>REMARKS</H3>
</P>
<P>
The SioWinError is a Win32 ONLY function that returns the last Win32 error code.  If 'Buffer' is not NULL, it will also copy the corresponding text message into 'Buffer' of maximum size 'Size'
</P>
<P>
<H3>EXAMPLE</H3>
</P>
<P>
<H3>C/C++ Example</H3>
</P>

<PRE>
     char Buffer[128]
     Code = SioWinError((LPSTR)Buffer, 128)

<H3>BASIC Example</H3>

     Dim Buffer As String * 128
     Code = SioWinError(Buffer, 128)
</PRE>

<P><H3>RETURNS</H3></P>

<P>The Win32 numeric error code.</P>

<BR>
<A NAME="Section_3"> </A>
<HR> <H2>3  Modem I/O Functions</H2>
<A NAME="Section_3.1"> </A>
<HR> <H2>3.1  mioBreak :: Aborts the Modem I/O state driver.</H2>

<P><H3>SYNTAX</H3></P>

<P>mioBreak(Port)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>

<P>Forces the MIO driver to the IDLE state, abandoning any work in progress (if any).  
Used to abort mioSendTo, mioQuiet, and mioWaitFor functions.</P>

<P><H3>RETURNS</H3></P>

<BLOCKQUOTE>
  <P>Return = MIO_IDLE.</P>

</BLOCKQUOTE>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = mioBreak(Port)</P>

  <BR>
</BLOCKQUOTE>
<A NAME="Section_3.2"> </A>
<HR> <H2>3.2  mioDriver :: Modem I/O state driver.</H2>

<P><H3>SYNTAX</H3></P>

<P>mioDriver(Port)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>Executes the next state of any previously started MIO function such as mioSendTo, 
mioWaitFor, and mioQuiet.  Returns MIO_IDLE (defined in MIO.H) if idle (not running), 
MIO_RUNNING if running, and anything else that is a character from the modem that can be 
displayed if wanted.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = MIO_IDLE  ( if the driver is ready for the next mioSendTo, mioWaitFor, or 
  mioQuiet)</LI>

  <LI>Return = MIO_RUNNING  (if the driver is not idle)</LI>

  <LI>Return = &lt;else&gt;  (if the driver is not idle, and the returned character was 
  received from the modem)</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = mioDriver(Port)</P>

  <BR>
</BLOCKQUOTE>
<A NAME="Section_3.3"> </A>
<HR> <H2>3.3  mioQuiet :: Waits for Modem I/O state driver.</H2>

<P><H3>SYNTAX</H3></P>


<P>mioQuiet(Port, Wait)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

  <P>Wait : (L) Wait in milliseconds.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The mioQuiet function waits for continuous quiet [no incoming serial data] of 'Wait' 
milliseconds before returning.  Any incoming characters while mioQuiet is running are 
lost.</P>


<P><H3>RETURNS</H3></P>

<BLOCKQUOTE>
  <P>Return = TRUE.</P>

</BLOCKQUOTE>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = mioQuiet(Port, 1000)</P>

  <BR>
</BLOCKQUOTE>
<A NAME="Section_3.4"> </A>
<HR> <H2>3.4  mioResult :: Returns result of last mioWaitFor.</H2>

<P><H3>SYNTAX</H3></P>


<P>mioResult(Port)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The mioResult function returns the result of the last mioWaitFor function.  This 
function should not be called until the driver returns MIO_IDLE.  See the remarks section 
of the mioWaitFor function for an example.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = 0  (False - last WaitFor not matched)</LI>

  <LI>Return = !0  ('0' if first substring matched, '1' if second substring matched, 
  etc.)</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = mioResult(Port)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>mioWaitFor.</P>

<A NAME="Section_3.5"> </A>
<HR> <H2>3.5  mioSendTo :: Sends string to modem.</H2>

<P><H3>SYNTAX</H3></P>


<P>mioSendTo(Port, Pace, Text)</P>

<BLOCKQUOTE>
  <P>Port   : (I) Port selected.</P>

  <P>Pace   : (L) The inter-character delay in milliseconds.</P>

  <P>String : (P) The string to send.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The mioSendTo function sends the characters in the string 'Text' to serial output.  There is a delay of 'Pace' milliseconds between characters.  Three characters in 'Text' are interpreted as:
</P>
<P>
<BR>

<PRE>
     [NAME]       :  [FUNCTION]
     char is '^'  :  next character is control char (^A for 0x01)
     char is '!'  :  replaced with carriage return.
     char is '~'  :  removed from string (delay 1/2 second).
</PRE>

</P>

<P><H3>RETURNS</H3></P>

<BLOCKQUOTE>
  <P>Return = TRUE.</P>

</BLOCKQUOTE>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = mioSendTo(Port, 100, "ATDT555~1212!")</P>

  <BR>
</BLOCKQUOTE>
<A NAME="Section_3.6"> </A>
<HR> <H2>3.6  mioWaitFor :: Waits for continuous quiet.</H2>

<P><H3>SYNTAX</H3></P>

<P>mioWaitFor(Port, Wait, Text)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

  <P>Wait : (L) Total time to wait for response (milliseconds).</P>

  <P>Text : (P) The expected response string.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>

<P>The mioWaitFor function waits for characters from serial input that match the string 
'Text'.  A total of 'Wait' milliseconds are allowed before timing out and returning FALSE 
(0).  The string comparison is NOT case sensitive.</P>

<P>The function mioDriver() must be called until MIO_IDLE is returned.  Then mioResult() 
is called to get the result of the mioWaitFor.  Looking at the example below, a value of 0 
indicates that neither "CONNECT", "BUSY", nor "NO CARRIER" was received.  A non-zero value 
indicates that one of the three sub-strings was received.  A '0' is returned if "CONNECT" 
was seen, '1' is returned if "NO CARRIER" was seen, and '2' is returned if "BUSY" was 
seen.
</P>

<P><H3>RETURNS</H3></P>

<P>A character as described above.</P>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = mioWaitFor(Port, 60000, "CONNECT|NO  CARRIER|BUSY")</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>

<P>mioResult.</P>

<A NAME="Section_4"> </A>
<HR> <H2>4  XYM Functions</H2>
<A NAME="Section_4.1"> </A>
<HR> <H2>4.1  xyAbort :: Aborts the XYDRIVER state driver.</H2>

<P><H3>SYNTAX</H3></P>

<P>xyAbort(Port)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>

<P>The xyAbort function forces the driver to IDLE, terminating any file transfer that may 
be in progress.</P>

<P><H3>RETURNS</H3></P>

<BLOCKQUOTE>
  <P>Return = XY_NO_ERROR (0).</P>

</BLOCKQUOTE>


<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = xyAbort(Port)</P>

  <BR>
</BLOCKQUOTE>
<A NAME="Section_4.2"> </A>
<HR> <H2>4.2  xyAcquire :: Prepares the state driver for operation.</H2>

<P><H3>SYNTAX</H3></P>


<P>xyAcquire(FirstPort, LastPort)</P>

<BLOCKQUOTE>
  <P>FirstPort : (I) First port selected.</P>

  <P>LastPort  : (I) Last port selected.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>The xyAcquire function initializes the driver for subsequent use. This should be the 
first driver function called.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = =0  (No error [XY_NO_ERROR])</LI>

  <LI>Return = &lt;0  (XYDRIVER error. See "XYDRIVER Error Codes")</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = xyAcquire(COM1, COM1)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>xyRelease.</P>

<A NAME="Section_4.3"> </A>
<HR> <H2>4.3  xyDebug :: Set the driver debug level.</H2>

<P><H3>SYNTAX</H3></P>


<P>xyDebug(Level)</P>

<BLOCKQUOTE>
  <P>Level : (I) Debug level value.</P>

</BLOCKQUOTE>

<P><H3>REMARKS</H3></P>


<P>
The xyDebug functions sets the driver debug level as follows:
</P>
<P>
<BR>

<PRE>
     [LEVEL]        [FUNCTION]
     Level is 0  :  Only error messages are generated (default).
     Level is 1  :  Minimal debug messages are generated.
     Level is 2  :  Maximal debug messages are generated.
</PRE>

</P>


<P><BR>
Debug messages are retrieved using the xyGetMessage function.</P>


<P><H3>RETURNS</H3></P>


<P>New debug level [0,1,2]</P>


<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = xyDebug(0)</P>

</BLOCKQUOTE>

<P><H3>ALSO SEE</H3></P>


<P>xyGetMessage.</P>

<A NAME="Section_4.4"> </A>
<HR> <H2>4.4  xyDriver :: XMODEM / YMODEM state driver.</H2>

<P><H3>SYNTAX</H3></P>


<P>xyDriver(Port)</P>

<BLOCKQUOTE>
  <P>Port : (I) Port selected.</P>

</BLOCKQUOTE>

<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = XY_IDLE : A transfer is not underway.
  <BR><BR>
  <BR></LI>

</UL>

<P><H3>REMARKS</H3></P>


<P>The xyDriver function drives the state engine.  Note that xyDriver never returns an 
error code.</P>


<P>In order to send or to receive a file, call xyDriver in a loop until it returns XY_IDLE 
(numerical 0) after first initiating the transfer by calling either xyStartTx or 
xyStartRx.</P>


<P>xyDriver can be called as often as wanted whether or not a file transfer was initiated.</P>


<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = xyDriver(Port)<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>ALSO SEE</H3>
</P>
<P>
xyStartTx and xyStartRx.
</P>
<A NAME="Section_4.5"> </A>
<HR> <H2>4.5  xyGetFileName :: Get the filename from packet 0</H2>
<P>
<H3>SYNTAX</H3>
</P>
<P>
xyGetFileName(Port, Buffer, Size)
</P>
<BLOCKQUOTE>
  <P>
  Port   : (I) Port selected.<BR>
  </P>
  <P>
  Buffer : (P) Filename buffer.<BR>
  </P>
  <P>
  Size   : (I) Size of Filename buffer.<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>REMARKS</H3>
</P>
<P>
The xyGetFileName function gets the current filename.  This function is designed for use on the receive side YMODEM protocol, where the filename is received as part of the first packet (packet #0).  See the TERM example program.
</P>
<P>
<H3>RETURNS</H3>
<BR>
</P>
<UL>
  <LI>
  Return = TRUE  (A message was copied into Buffer)
  </LI>
  <LI>
  Return = FALSE  (No messages are available)
  </LI>
</UL>
<P>
<H3>EXAMPLE</H3>
</P>
<P>
<H3>C/C++ Example</H3>
</P>

<PRE>
     char Buffer[40]
     Code = xyGetFileName(Port, (LPSTR)Buffer, 40)

<H3>BASIC Example</H3>

     Dim Buffer As String * 40
     Code = xyGetFileName(Port, Buffer, 40)
</PRE>

<P>
<H3>ALSO SEE</H3>
</P>
<P>
xyGetParameter.
</P>
<A NAME="Section_4.6"> </A>
<HR> <H2>4.6  xyGetMessage :: Get next XYDRIVER message.</H2>
<P>
<H3>SYNTAX</H3>
</P>
<P>
xyGetMessage(Port, Buffer, Size)
</P>
<BLOCKQUOTE>
  <P>
  Port   : (I) Port selected.<BR>
  </P>
  <P>
  Buffer : (P) Message buffer.<BR>
  </P>
  <P>
  Size   : (I) Size of message buffer.<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>REMARKS</H3>
</P>
<P>
The xyGetMessage function retrieves the next message from the driver message queue.  Refer to the TERM example program for an example of using xyGetMessage.
</P>
<P>
<H3>RETURNS</H3>
<BR>
</P>
<UL>
  <LI>
  Return = TRUE  (A message was copied into Buffer)
  </LI>
  <LI>
  Return = FALSE  (No messages are available)
  </LI>
</UL>
<P>
<H3>EXAMPLE</H3>
</P>
<P>
<H3>C/C++ Example</H3>
</P>

<PRE>
     char Buffer[40]
     Code = xyGetMessage (Port, (LPSTR)Buffer, 40)

<H3>BASIC Example</H3>

     Dim Buffer As String * 40
     Code = xyGetMessage(Port, Buffer, 40)
</PRE>

<P>
<H3>ALSO SEE</H3>
</P>
<P>
xyDebug.
</P>
<P>
<BR>
</P>
<A NAME="Section_4.7"> </A>
<HR> <H2>4.7  xyGetParameter :: Retrieves driver parameter.</H2>
<P>
<H3>SYNTAX</H3>
</P>
<P>
xyGetParameter(Port, Parm)
</P>
<BLOCKQUOTE>
  <P>
  Port : (I) Port Selected.<BR>
  </P>
  <P>
  Parm : (I) Parameter to return.<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>REMARKS</H3>
</P>
<P>
The parameter value corresponding to the following table is returned.
</P>

<PRE>
     [NAME]               :  [FUNCTION]
     XY_GET_VERSION       :  Returns XYM version (a.b.c).
     XY_GET_BUILD         :  Returns XYM build number.
     XY_GET_ERROR_CODE    :  Driver error code (see XYM.H)
     XY_GET_ERROR_STATE   :  Error state (if in error).
     XY_GET_PACKET        :  Current packet number.
     XY_GET_STATE         :  Current state (see XYDRIVER.C).
     XY_GET_FILE_SIZE     :  File size.
     XY_GET_NBR_NAKS      :  Get number of packets ACK'ed.
     XY_GET_LAST_GET      :  Last incoming (serial) character.
     XY_GET_LAST_PUT      :  Last outgoing (serial) character.
     XY_GET_GET_COUNT     :  Number of incoming characters (bytes).
     XY_GET_PUT_COUNT     :  Number of outgoing characters (bytes).
     XY_GET_DRIVER_COUNT  :  Number times xyDriver() was called.
     XY_GET_SHORT_PACKETS :  Get number of short packets (RX side only).
     XY_GET_PACKETS_ACKED :  Get number of packets ACK'ed.
     -1                   :  Cannot recognize parameter.
</PRE>

<P>The xyGetParameter function can be used to check the state of the driver.  For 
example:</P>

<OL type="1" start="1">
  <LI VALUE="1">
  xyGetParameter(Port, XY_GET_STATE) returns XY_IDLE if idle.</LI>

  <LI VALUE="2">
  xyGetParameter(Port, XY_GET_ERROR_CODE) returns the driver error code if an error has 
  occurred or XY_NO_ERROR (0) otherwise.</LI>

</OL>

<P><H3>RETURNS</H3></P>


<P>See above.</P>


<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>     Code = xyGetParameter(Port, XY_GET_VERSION)</P>

  <BR>
</BLOCKQUOTE>
<A NAME="Section_4.8"> </A>
<HR> <H2>4.8  xyRelease :: Releases driver port.</H2>

<P><H3>SYNTAX</H3></P>


<P>xyRelease()</P>


<P><H3>REMARKS</H3></P>


<P>The xyRelease function releases the ports that were previously acquired with xyAcquire. 
 This function should be called before calling the WSC function SioDone.</P>


<P><H3>RETURNS</H3></P>

<UL>
  <LI>Return = 0  (No error [XY_NO_ERROR])</LI>

  <LI>Return = &lt;0  (XYDRIVER error. See "XYDRIVER Error Codes")</LI>

</UL>

<P><H3>EXAMPLE</H3></P>

<BLOCKQUOTE>
  <P>
       Code = xyRelease()<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>ALSO SEE</H3>
</P>
<P>
xyAcquire.
</P>
<A NAME="Section_4.9"> </A>
<HR> <H2>4.9  xySetParameter :: Sets driver parameter.</H2>
<P>
<H3>SYNTAX</H3>
</P>
<P>
xySetParameter(Port, ParmName, ParmValue)
</P>

<PRE>
   Port      : (I) Port Selected.
   ParmName  : (I) Parameter Name.
   ParmValue : (L) Parameter Value.
</PRE>

<P>
<H3>REMARKS</H3>
</P>
<P>
The ParmValue corresponding to the following table is set.
</P>

<PRE>
     [NAME]                       :  [FUNCTION]
     ParmName = XY_SET_NAK_RATE   :  Sets the prompt delay (in seconds).
     ParmName = XY_SET_EOF_CHAR   :  Sets the XMODEM pad character.
     ParmName = XY_SET_ONE_SECOND :  Sets the # milliseconds second.
</PRE>

<P>
The XY_SET_NAK_RATE parameter sets the delay (in seconds) between prompts that the receiver transmits to the sender to start the file transfer.  The legal range is 1 to 10 seconds.
</P>
<P>
The XY_SET_EOF_CHAR parameter sets the pad character used by XMODEM in padding the last packet to 128 bytes.  The normal value is control-Z (hex 1A).
</P>
<P>
The XY_SET_ONE_SECOND parameter (if set to less than 1000)  is used to speed up the protocol by reducing waits. To reduce all time delays to half of their default value, use 500.
</P>
<P>
<H3>RETURNS</H3>
</P>
<P>
See above.
</P>
<P>
<H3>EXAMPLE</H3>
</P>
<BLOCKQUOTE>
  <P>
       Code = xySetParameter(Port, XY_SET_EOF_CHAR, 0)<BR>
  </P>
  <P>
  <BR>
  </P>
</BLOCKQUOTE>
<A NAME="Section_4.10"> </A>
<HR> <H2>4.10  xySetString :: Set Upload/Download Directory String.</H2>
<P>
<H3>SYNTAX</H3>
</P>
<P>
xySetString(Port, ParamName, ParamString)
</P>

<PRE>
   Port        : (I) Port to use.
   ParamName   : (I) Parameter name
   ParamString : (P) Pointer to parameter string
</PRE>

<P>
<H3>REMARKS</H3>
</P>
<P>
They location of the local upload/download directory can be specified by passing XY_SET_FILES_DIR as the ParamName and a pointer to the requested directory as ParamString.
</P>
<P>
If the local upload/download directory is not specified, then the current directory is the default location.
</P>
<P>
<H3>RETURNS</H3>
<BR>
</P>
<UL>
  <LI>
  Return &gt; 0   (No error)
  </LI>
  <LI>
  Return = -1  (ParamName is not recognized)
  </LI>
</UL>
<P>
<H3>EXAMPLE</H3>
</P>
<P>
<H3>C/C++ Example</H3>
</P>
<BLOCKQUOTE>
  <P>
       Code = xySetString(Port, XY_SET_FILES_DIR, "C:\\WINDOWS\TEMP");<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>BASIC Example</H3>
</P>
<BLOCKQUOTE>
  <P>
       Code = xySetString(Port, XY_SET_FILES_DIR, "C:\WINDOWS\TEMP")<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>ALSO SEE</H3>
</P>
<P>
None.
</P>
<A NAME="Section_4.11"> </A>
<HR> <H2>4.11  xyStartRx :: Start XMODEM or YMODEM receive.</H2>
<P>
<H3>SYNTAX</H3>
</P>
<P>
xyStartRx(Port, Filename, NCGchar, Batch)
</P>

<PRE>
   Port     : (I) Port to use.
   Filename : (P) File to receive (XMODEM only).
   NCGchar  : (I) NAK, 'C', or 'G'.
   Batch    : (I) YMODEM flag (T/F).
</PRE>

<P>
<H3>REMARKS</H3>
</P>
<P>
The xyStartRx starts the XMODEM or YMODEM file receive.  Once started, calls to xyDriver are made to execute the next state (or states).  The xyStartTx function returns immediately.  The protocols supported and their parameters are as follows:
</P>

<PRE>
     [Protocol]  :  [NCGchar]  [BatchFlag]
     XMODEM      :     NAK      FALSE          (Standard XMODEM)
     XMODEM/CRC  :    'C'       FALSE
     XMODEM/1K   :    'C'       FALSE
     YMODEM      :    'C'       TRUE           (Standard YMODEM)
</PRE>

<P>
<H3>RETURNS</H3>
<BR>
</P>
<UL>
  <LI>
  Return = TRUE  (No error)
  </LI>
  <LI>
  Return = FALSE  (Not started. Port not active)
  </LI>
</UL>
<P>
<H3>EXAMPLE</H3>
</P>
<P>
<H3>C/C++ Example</H3>
</P>
<BLOCKQUOTE>
  <P>
       Code = xyStartRx(Port, "MYFILE.ZIP", 'C', 1)<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>BASIC Example</H3>
</P>
<BLOCKQUOTE>
  <P>
       Code = xyStartRx(Port, "MYFILE.ZIP", ASC("C"), 1)<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>ALSO SEE</H3>
</P>
<P>
xyStartTx and xyDriver.
</P>
<A NAME="Section_4.12"> </A>
<HR> <H2>4.12  xyStartTx :: Start XMODEM or YMODEM transmit.</H2>
<P>
<H3>SYNTAX</H3>
</P>
<P>
xyStartTx(Port, Filename, OneK, Batch)
</P>

<PRE>
   Port     : (I) Port to use.
   Filename : (P) File to send.
   OneK     : (I) Want 1K blocks (T/F).
   Batch    : (I) YMODEM flag (T/F).
</PRE>

<P>
<H3>REMARKS</H3>
</P>
<P>
The xyStartTx starts the XMODEM or YMODEM file send.  Once started, calls to xyDriver are made to execute the next state (or states).  The xyStartTx function returns immediately.  The protocols supported and their parameters are as follows:
</P>

<PRE>
     [Protocol]  :  [OneKflag]  [BatchFlag]
     XMODEM      :    FALSE      FALSE       Standard XMODEM
     XMODEM/CRC  :    FALSE      FALSE
     XMODEM/1K   :    TRUE       FALSE
     YMODEM      :    TRUE       TRUE        Standard YMODEM
</PRE>

<P>
<H3>RETURNS</H3>
<BR>
</P>
<UL>
  <LI>
  Return = TRUE  (No error)
  </LI>
  <LI>
  Return = FALSE  (Not started. Port not active)
  </LI>
</UL>
<P>
<H3>EXAMPLE</H3>
</P>
<BLOCKQUOTE>
  <P>
       Code = xyStartTx(Port, "MYFILE.ZIP", 0, 1)<BR>
  </P>
</BLOCKQUOTE>
<P>
<H3>ALSO SEE</H3>
</P>
<P>
xyStartRx and xyDriver.
</P>
<P>
<BR>
</P>
<A NAME="Section_5"> </A>
<HR> <H2>5  Error Codes</H2>
<A NAME="Section_5.1"> </A>
<HR> <H2>5.1  WSC Error Codes</H2>

<PRE>

     [NAME]           :  [FUNCTION]
     WSC_ABORTED      :  The evaluation version of WSC corrupted.
     WSC_BUFFERS      :  Cannot allocate memory for buffers.
     WSC_EXPIRED      :  Evaluation version expired.
     WSC_KEYCODE      :  Bad key code value.
     WSC_NO_DATA      :  No incoming serial data is available.
     WSC_RANGE        :  A parameter is out of range.
     WSC_THREAD       :  Cannot start thread.
     WSC_WIN32ERR     :  Win32 system error.
     WSC_IE_BADID     :  No such port.
     WSC_IE_BAUDRATE  :  Unsupported byte size.
     WSC_IE_BYTESIZE  :  Unsupported byte size.
     WSC_IE_DEFAULT   :  Error in default parameters
     WSC_IE_HARDWARE  :  COM port hardware not present
     WSC_IE_MEMORY    :  Cannot allocate memory.
     WSC_IE_NOPEN     :  Port not opened. Call SioReset first.
     WSC_IE_OPEN      :  Port already opened.
     WSC_IO_ERROR     :  An event error has occurred.
</PRE>

<P>
The WSC_ABORTED error occurs in the evaluation version only if there is a problem displaying the software info screen.
</P>
<P>
The WSC_WIN32ERR error code is returned only for Win32 system errors.  Call SioWinError to retrieve the error message.
</P>
<A NAME="Section_5.2"> </A>
<HR> <H2>5.2   XYDRIVER Error Codes</H2>
<P>
Error codes are always negative, except for "no error".  Most of these error conditions rarely occur.  Also note that XYDRIVER functions can return WSC errors.  An error message is queued when an error occurs which can be retrieved with xyGetMessage.
</P>

<PRE>
     [NAME]                    :  [FUNCTION]
     XY_NO_ERROR               :  No error.
     XY_UNKNOWN_ERROR          :  Unknown error.
     XY_ALREADY_ACTIVE_ERROR   :  Port already acquired.
     XY_CANNOT_OPEN_ERROR      :  Cannot open specified file.
     XY_EMPTY_FILE_ERROR       :  Specified file is empty.
     XY_NO_STARTUP_CHAR_ERROR  :  Must specify NAK, 'C', or 'G'.
     XY_NOT_NCG_ERROR          :  Expected NAK, 'C', or 'G'.
     XY_DISK_READ_ERROR        :  Error reading disk.
     XY_NO_EOT_ACK_ERROR       :  EOT was not ACK'ed.
     XY_INTERNAL_ERROR         :  Internal error!
     XY_CANCELLED_ERROR        :  Other side canceled.
     XY_OUT_OF_SYNC_ERROR      :  Protocol has lost synchronization.
     XY_RETRIES_ERROR          :  Packet retry limit was exceeded.
     XY_BAD_PACKET_NBR_ERROR   :  Incorrect packet number.
     XY_TIMED_OUT_ERROR        :  Timed out waiting for other side.
     XY_NO_SUCH_FILE_ERROR     :  No such file.
     XY_NOT_ACTIVE_ERROR       :  Port not acquired by xyAcquire.
     XY_PORT_RANGE_ERROR       :  Port number out of range.

The latest versions of WSC are available on our web site at

      http://www.marshallsoft.com/serial-communication-library.htm
</PRE>

<BR>
</BODY>
</HTML>
